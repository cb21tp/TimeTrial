###############################
AUC_TimeCycle <- apply(TC_results, 2,FUN = function(exprResult){
expected <- c(rep(1,7000),rep(0,4000))
pred <- as.numeric(as.vector(unlist(exprResult)))
ROC <- roc(expected,pred)
as.vector(ROC$auc)
} )
##--------------------------------------- Preprocessing JTK_Cycle Data --------------------------------
##########################
#LOAD THE DATA INTO R JTK
##########################
setwd("~/Desktop/TimeCycleV3/Results/Synthetic/JTK/")
all.files <- as.list(dir())
#get Timecycle Results
count <- 0
data <- lapply(all.files,FUN = function(x){
count <<- count + 1
load(all.files[[count]])
attach(all.files[[count]],warn=FALSE)
df <- get("results",pos=paste0("file:",all.files[[count]]))
assign(paste(all.files[[count]], sep = ""), df)
})
names(data) <- all.files
###############################
#EXTRACT DATA FRAME OF INTEREST
###############################
#get the adjusted pvalues and make them into a singel dataframe
JTK_results<- lapply(data, function(df){
df$ADJ.P
})
JTK_results <- do.call(cbind,JTK_results)
rownames(JTK_results) <- rownames(data[[1]])
JTK_results <- as.data.frame(JTK_results)
###############################
# GET AUC Value OF JTK_Results
###############################
AUC_JTK <- apply(JTK_results,2,FUN = function(exprResult){
expected <- c(rep(1,7000),rep(0,4000))
pred <- as.numeric(as.vector(unlist(exprResult)))
ROC <- roc(expected,pred)
as.vector(ROC$auc)
} )
##------------------------------------------- Preprocessing Sw1pers Data --------------------------------
##########################
#LOAD THE DATA INTO R Sw1pers
##########################
setwd("~/Desktop/TimeCycleV3/Results/Synthetic/Sw1pers-r/")
all.files <- as.list(dir())
#get Timecycle Results
data <- lapply(all.files,function(x){
read.delim(x, quote = "")
})
names(data) <- all.files
###############################
#EXTRACT DATA FRAME OF INTEREST
###############################
#get the adjusted pvalues and make them into a singel dataframe
sw1per_results<- lapply(data, function(df){
df$score
})
sw1per_results <- do.call(cbind,sw1per_results)
rownames(sw1per_results) <- data[[1]]$id
sw1per_results <- as.data.frame(sw1per_results)
###############################
# GET AUC Value OF JTK_Results
###############################
AUC_sw1pers <- apply(sw1per_results,2,FUN = function(exprResult){
expected <- c(rep(1,7000),rep(0,4000))
pred <- as.numeric(as.vector(unlist(exprResult)))
ROC <- roc(expected,pred)
as.vector(ROC$auc)
} )
##################################################
#LOAD META DATA INTO R SAME FOR JTK, TIMECYCLE, and Sw1pers
##################################################
metaData <- read.delim(file = "~/Desktop/TimeCycleV3/Scripts/Synthetic/masterFilePath_timeCycle.txt",header = F)
colnames(metaData) <- as.vector(unlist(metaData[226,]))
metaData <- metaData[c(-226),]
##############################################################
# get the number of samples for each graph
##############################################################
tp <- as.numeric(as.character(metaData$TimePoints))
reps <- as.numeric(as.character(metaData$reps))
numSamples <- tp*reps
metaInfo <- regmatches(names(AUC_TimeCycle), gregexpr("[[:digit:]]+\\.*[[:digit:]]*", names(AUC_TimeCycle)))
metaInfo <- do.call(rbind,metaInfo)
noiseLevels <- as.numeric(metaInfo[,3])
intervals <- as.numeric(metaInfo[,1])
repli <- as.numeric(metaInfo[,4])
#select points to be plotted
keep <- which(metaData$FileName %in% gsub(pattern = ".Rdata",replacement = "", x = names(AUC_TimeCycle)))
#colors for Methods
# JTK [1], TC [2], Sw1per [3]
col_pal_fill <- c("#ff7f00","#377eb8","grey")
col_pal_outline <- rep('black',3)
trnplvl <- 1 #transparency Level
#TimeCycle vs JTK_Cycle
#set up plotting aread
par(font = 2)
plot(x = NULL,
y = NULL,
pch = 15+repli,
cex = 1+noiseLevels,
xlim = range(numSamples),
ylim = range(as.vector(AUC_TimeCycle)),
xlab = "Number of Samples",
ylab = "AUC",
font.axis = 2,
font.lab = 2,
axes = F)
# rect(par("usr")[1],par("usr")[3],par("usr")[2],par("usr")[4],col = "lightgray", border = F)
axis(side = 1,lwd = 2, tick = 2)
axis(side = 2,lwd = 2)
box(lwd = 3)
#plot trend lines
y <- as.vector(AUC_JTK)
fitJTK <- nls(y ~ 1 - b * exp(-z*numSamples), start = list(b = 1, z = .001))
lines(sort(numSamples),sort(fitted(fitJTK)), col = col_pal_fill[2], lwd = 6)
y <- as.vector(AUC_TimeCycle)
fitTC <- nls(y ~ 1 - b * exp(-z*numSamples[keep]), start = list(b = 1, z = .001))
lines(sort(numSamples[keep]),sort(fitted(fitTC)), col = col_pal_fill[1], lwd = 6)
y <- as.vector(AUC_sw1pers)
fitSw <- nls(y ~ 1 - b * exp(-z*numSamples[keep]), start = list(b = 1, z = .001))
lines(sort(numSamples[keep]),sort(fitted(fitSw)), col = col_pal_fill[3], lwd = 6)
#TimeCycle vs JTK_Cycle
#set up plotting aread
par(font = 2)
plot(x = NULL,
y = NULL,
pch = 15+repli,
cex = 1+noiseLevels,
xlim = range(numSamples),
ylim = range(as.vector(AUC_TimeCycle)),
xlab = "Number of Samples",
ylab = "AUC",
font.axis = 2,
font.lab = 2,
axes = F)
# rect(par("usr")[1],par("usr")[3],par("usr")[2],par("usr")[4],col = "lightgray", border = F)
axis(side = 1,lwd = 2, tick = 2)
axis(side = 2,lwd = 2)
box(lwd = 3)
y <- as.vector(AUC_sw1pers)
fitSw <- nls(y ~ 1 - b * exp(-z*numSamples[keep]), start = list(b = 1, z = .001))
lines(sort(numSamples[keep]),sort(fitted(fitSw)), col = col_pal_fill[3], lwd = 6)
y <- as.vector(AUC_JTK)
fitJTK <- nls(y ~ 1 - b * exp(-z*numSamples), start = list(b = 1, z = .001))
lines(sort(numSamples),sort(fitted(fitJTK)), col = col_pal_fill[2], lwd = 6)
y <- as.vector(AUC_TimeCycle)
fitTC <- nls(y ~ 1 - b * exp(-z*numSamples[keep]), start = list(b = 1, z = .001))
lines(sort(numSamples[keep]),sort(fitted(fitTC)), col = col_pal_fill[1], lwd = 6)
#plot JTK results
points(x = numSamples,
y = as.vector(AUC_JTK),
# pch = 15+repli,
col = col_pal_outline[2],
bg = alpha(col_pal_fill[2],trnplvl),
pch = 21,
cex = 1+noiseLevels)
#plot TC results
points(x = numSamples[keep],
y = as.vector(AUC_TimeCycle),
bg = alpha(col_pal_fill[1],trnplvl),
col = col_pal_outline[1],
# pch = 15+repli,
pch = 21,
cex = 1+noiseLevels)
#plot Sw1pers results
points(x = numSamples,
y = as.vector(AUC_sw1pers),
# pch = 15+repli,
col = col_pal_outline[3],
bg = alpha(col_pal_fill[3],trnplvl),
pch = 21,
cex = 1+noiseLevels)
#plot TC results
points(x = numSamples[keep],
y = as.vector(AUC_TimeCycle),
bg = alpha(col_pal_fill[1],trnplvl),
col = col_pal_outline[1],
# pch = 15+repli,
pch = 21,
cex = 1+noiseLevels)
#colors for Methods
# JTK [1], TC [2], Sw1per [3]
col_pal_fill <- c("#ff7f00","#377eb8","grey")
col_pal_outline <- rep('black',3)
trnplvl <- 1 #transparency Level
#TimeCycle vs JTK_Cycle
#set up plotting aread
par(font = 2)
plot(x = NULL,
y = NULL,
pch = 15+repli,
cex = 1+noiseLevels,
xlim = range(numSamples),
ylim = range(as.vector(AUC_TimeCycle)),
xlab = "Number of Samples",
ylab = "AUC",
font.axis = 2,
font.lab = 2,
axes = F)
# rect(par("usr")[1],par("usr")[3],par("usr")[2],par("usr")[4],col = "lightgray", border = F)
axis(side = 1,lwd = 2, tick = 2)
axis(side = 2,lwd = 2)
box(lwd = 3)
y <- as.vector(AUC_JTK)
fitJTK <- nls(y ~ 1 - b * exp(-z*numSamples), start = list(b = 1, z = .001))
lines(sort(numSamples),sort(fitted(fitJTK)), col = col_pal_fill[2], lwd = 6)
y <- as.vector(AUC_sw1pers)
fitSw <- nls(y ~ 1 - b * exp(-z*numSamples[keep]), start = list(b = 1, z = .001))
lines(sort(numSamples[keep]),sort(fitted(fitSw)), col = col_pal_fill[3], lwd = 6)
y <- as.vector(AUC_TimeCycle)
fitTC <- nls(y ~ 1 - b * exp(-z*numSamples[keep]), start = list(b = 1, z = .001))
lines(sort(numSamples[keep]),sort(fitted(fitTC)), col = col_pal_fill[1], lwd = 6)
#plot JTK results
points(x = numSamples,
y = as.vector(AUC_JTK),
# pch = 15+repli,
col = col_pal_outline[2],
bg = alpha(col_pal_fill[2],trnplvl),
pch = 21,
cex = 1+noiseLevels)
#plot Sw1pers results
points(x = numSamples,
y = as.vector(AUC_sw1pers),
# pch = 15+repli,
col = col_pal_outline[3],
bg = alpha(col_pal_fill[3],trnplvl),
pch = 21,
cex = 1+noiseLevels)
#plot TC results
points(x = numSamples[keep],
y = as.vector(AUC_TimeCycle),
bg = alpha(col_pal_fill[1],trnplvl),
col = col_pal_outline[1],
# pch = 15+repli,
pch = 21,
cex = 1+noiseLevels)
#add Legends
legend("bottomright",
legend = c("TimeCycle","JTK_Cycle","SW1PERS"),
fil = col_pal_fill,
title = "Method",
bg = NA,
box.lwd = 0)
library(shiny); runApp('~/Desktop/CyclingMethodsReview/DataAnalysis/Scripts/Figures/timeTrialRealDataComplete.R')
runApp('~/Desktop/CyclingMethodsReview/DataAnalysis/Scripts/Figures/timeTrialSyntheticData.R')
runApp('~/Desktop/TimeTrial/Scripts/TimeTrial_Apps/TimeTrial_Synthetic.R')
runApp('~/Desktop/TimeTrial/TimeTrial_Apps/TimeTrial_Real.R')
load("timeTrialRealDataComplete.RData")
runApp('~/Desktop/TimeTrial/TimeTrial_Apps/TimeTrial_Synthetic.R')
source('~/Desktop/TimeTrial/Scripts/Paper_Figures/Plot1A.R', echo=TRUE)
setwd("~/Desktop/TimeTrial/Data/Raw/RawData/")
#Load List of Text Files
fileNames <- list.files(pattern="*1.csv")
data <- lapply(fileNames, read.csv)
#set First Row to Row Names
data <- lapply(data, function(df){
rownames(df) <- df$X
df$X <- NULL
return(df)
})
#set Length of Time Series
timePoints <- seq(0,96,2)
#set Colors For plotting
cols <- c("#e41a1c","#377eb8","#4daf4a","#984ea3", "#ff7f00","#ffff33","#a65628","#cccccc", "#969696", "#636363", "#252525")
NoiseCols <- c("#058ed9","#0b5ea5","#073371","#00093f")
makePlot <- function(row,title,color){
base <- abs(min(data[[1]][row,]))
thinkness <- 1 #set thinkness to 0 to remove noise lines
plot(timePoints,data[[5]][row,]+base,
"l",
xlab = "Time Points",
ylab = "Expression",
col = 'black',
cex.lab = 1.25,
cex.axis = 1.5,
font.lab = 2,
font.axis = 2,
cex.main = 2,
lwd = thinkness,
pch = 16,
axes = F,
main = title)
axis(1, at = c(0,24,48,72,96), labels = c(0,24,48,72,96), font = 2, cex = 1.5)
axis(2, font = 2, cex = 1.5)
for(i in 5:2){
lines(timePoints,data[[i]][row,]+base, col = NoiseCols[i-1], lwd = thinkness)
}
lines(timePoints,data[[1]][row,]+base, col = color, lwd = 5)
box(lwd = 3)
}
{
par(mfrow = c(3,3))
makePlot(8,"Sin",cols[1])
makePlot(1008,"Peak",cols[2])
makePlot(2008,"Saw",cols[3])
makePlot(3012,"Linear Trend",cols[4])
makePlot(4008,"Damped",cols[5])
makePlot(5008,"Amplified",cols[6])
plot(1, type="n", xlab="", ylab="", axes = F, xlim=c(0, 10), ylim=c(0, 10))
makePlot(6008,"Contractile",cols[7])
par(mfrow = c(3,3))
makePlot(7010,"Flat",cols[8])
makePlot(8011,"Linear",cols[9])
plot(1, type="n", xlab="", ylab="", axes = F, xlim=c(0, 10), ylim=c(0, 10))
makePlot(9012,"Sigmoid",cols[10])
makePlot(10016,"Expenential",cols[11])
}
source('~/Desktop/TimeTrial/Scripts/Paper_Figures/Plot1B.R', echo=TRUE)
source('~/Desktop/TimeTrial/Scripts/Paper_Figures/Plot1B.R', echo=TRUE)
library(ggplot2)
library(pastecs)
library(tidyr)
library(pROC)
load("~/Desktop/TimeTrial/TimeTrial_Apps/timeTrialSyntheticDataTimeSeries.RData")
load("~/Desktop/TimeTrial/TimeTrial_Apps/timeTrialSyntheticDataResults.RData")
Reviewdf <- data
#Remove Length of 36 Hours
Reviewdf<- Reviewdf[which(Reviewdf$Length != 36),]
#######################################################
#Create a Data Frame of the Basic Statitics in Each Run
#######################################################
getSummaryStats <- split(Reviewdf,f = interaction(Reviewdf$Rate,Reviewdf$Length,Reviewdf$Method,Reviewdf$Rep),drop = T)
getSummaryStats <- lapply(getSummaryStats, function(x) {
vals <- x$AUC
output <- c(x$Rate[1],x$Length[1],x$Method[1],x$Rep[1], ((x$Length[1]/x$Rate[1]+1)*x$Rep[1]))
names(output) <- c("Rate","Length","Method","Rep", "NumSmp")
c(output,stat.desc(vals))
})
SummaryStats <- as.data.frame(t(do.call(cbind.data.frame, getSummaryStats)))
rownames(SummaryStats) <- NULL
SummaryStats <- SummaryStats[order(-as.numeric(SummaryStats$mean)),]
SummaryStats <- apply(SummaryStats,2,as.vector)
SummaryStats <- as.data.frame(SummaryStats)
##################################################
#High Noise Vs Low Noise - Concatination vs Avg
##################################################
par(cex.lab=1.5, cex.axis=1, cex.main=1.5, cex.sub=1.5, font.lab=2, font.axis = 2)
HighLowDfMean <- function(df, method, lng, smps, reps){
HighLowDf <- df[(df$Noise != 0.2 & df$Rep != reps & df$Length == lng & df$numSmps < smps & df$Method == method),]
Boot_Concat <- split(HighLowDf,interaction(HighLowDf$Noise < 0.2,HighLowDf$Rate,HighLowDf$Length, HighLowDf$Rep),drop = T)
names(Boot_Concat)
df <- as.data.frame(t(data.frame(strsplit(names(Boot_Concat), "[.]"))))
df$V5 <- unlist(lapply(Boot_Concat,function(x){mean(x$AUC)}))
df$NumSmp <- as.numeric((as.numeric(as.vector(df$V3))/as.numeric(as.vector(df$V2))+1)*as.numeric(as.vector(df$V4)))
names(df) <- c("NoiseHL","Rate","Length","Rep","AUC", "NumSmp")
df$NoiseHL <- as.factor(c("High", "Low")[as.numeric(as.factor(df$NoiseHL))])
return(df)
}
getMeans <- function(data){
a<- split(data$AUC,interaction(data$NumSmp,data$NoiseHL))
df <- as.data.frame(t(data.frame(strsplit(names(a), "[.]"))))
df$V3 <- unlist(lapply(a,mean))
df$V1 <- as.numeric(as.vector(df$V1))
names(df) <- c("numSmp", "NoiseHL", "AUC")
return(df)
}
unique(Reviewdf$Method)
#Select Only 24 Hours with more than 1 replicates
df_CON <- HighLowDfMean(data, "BooteJTK_Concat", 24, 41, 1)
#Select Only 48 Hours with more less than max sampling of 24 hour appove
df_AVG <- HighLowDfMean(data, "BooteJTK_Avg", 48, 41, 0)
#Get Mean Values of AUC for each Sampling Between High and Low Noise Levels
meanLine_Avg <- getMeans(df_AVG)
meanLine_Con <- getMeans(df_CON)
colsLines <- c("#377eb8", "#377eb8", "#7F7F7F","#7F7F7F")
colsFill <- c("#FFFFFF",alpha("#377eb8",0.8),"#FFFFFF", alpha("#7F7F7F",0.8))
pchShape <- c(21,23,24)
pchLines <- c(21,23)
fitAvg <- glm(formula = AUC ~ numSmp*NoiseHL,data = meanLine_Avg)
fitCon <- glm(formula = AUC ~ numSmp*NoiseHL,data = meanLine_Con)
summary(fitAvg)
summary(fitCon)
lwdCenter <- 5
par(mfrow = c(2,1), font = 2)
plot(as.numeric(as.vector(meanLine_Avg[meanLine_Avg$NoiseHL=="High",]$numSmp)),
meanLine_Avg[meanLine_Avg$NoiseHL=="High",]$AUC, col = colsLines[2],
type = "l",
lwd = 0,
xlim = c(5,42),
ylim = c(0.5,1),
xlab = "Number of Samples",
ylab = "AUC Score",
main = "AUC Score in Low Noise Regime")
#Plot Trend Lines
abline(v = 26, lwd = 2, col = "orange")
abline(a = fitAvg$coefficients[1] + fitAvg$coefficients[3], b =fitAvg$coefficients[2]+ fitAvg$coefficients[4], col = colsLines[2], lwd = lwdCenter)
abline(a = fitCon$coefficients[1] + fitCon$coefficients[3], b =fitCon$coefficients[2]+ fitCon$coefficients[4], col = colsLines[4], lwd = lwdCenter)
#Blot Boarder
box(lwd=4)
#Plot Points
toPlot <- which(df_CON$NoiseHL == "Low")
points(df_CON$NumSmp[toPlot],df_CON$AUC[toPlot], col = colsLines[4],  bg  = colsFill[4], pch = pchLines[1], cex = 2, lwd = 3)
points(df_AVG$NumSmp[toPlot],df_AVG$AUC[toPlot], col = colsLines[2], bg  = colsFill[2], pch = pchLines[2], cex = 2, lwd = 3)
#Plot Legend
legend("bottomright",
legend= c("Concatenated 24h","Averaged 48h"),
col = colsLines[c(4,2)],
pch=pchLines,
pt.bg = colsFill[c(4,2)],
pt.cex = 2,
lwd = 2,
bty = "n",
box.lwd = 0)
# High Noise Plot
plot(as.numeric(as.vector(meanLine_Avg[meanLine_Avg$NoiseHL=="High",]$numSmp)),
meanLine_Avg[meanLine_Avg$NoiseHL=="High",]$AUC, col = colsLines[2],
type = "l",
lwd = 0,
xlim = c(5,42),
ylim = c(0.5,1),
xlab = "Number of Samples",
ylab = "AUC Score",
main = "AUC Score in High Noise Regime")
abline(v = 26, lwd = 2, col = "orange")
abline(a = fitAvg$coefficients[1], b =fitAvg$coefficients[2], col = colsLines[1], lwd = lwdCenter)
abline(a = fitCon$coefficients[1], b =fitCon$coefficients[2], col = colsLines[3], lwd = lwdCenter)
#Blot Boarder
box(lwd=4)
toPlot <- which(df_CON$NoiseHL == "High")
points(df_CON$NumSmp[toPlot],df_CON$AUC[toPlot], col = colsLines[4],  bg  = colsFill[4], pch = pchLines[1], cex = 2, lwd = 3)
points(df_AVG$NumSmp[toPlot],df_AVG$AUC[toPlot], col = colsLines[2], bg  = colsFill[2], pch = pchLines[2], cex = 2, lwd = 3)
#Plot Legend
legend("bottomright",
legend= c("Concatenated 24h","Averaged 48h"),
col = colsLines[c(4,2)],
pch=pchLines,
pt.bg = colsFill[c(4,2)],
pt.cex = 2,
lwd = 2,
bty = "n",
box.lwd = 0)
catergory <- c(rep(1,7000), rep(0,4000))
x <- c(0,0.1,0.2,0.3,0.4)
par(cex.lab=1.5, cex.axis=1, cex.main=1.5, cex.sub=1.5, font.lab=2, font.axis = 2)
lineColors <- c("grey",'#fff800','#f37200','#cf0000','#000000')
####
#BooteJTK_Concat_2_48_",x,"_1" Plots
#####
par(font=2)
BooteJTKsamples <- paste0("BooteJTK_Avg_2_48_",x,"_1")
for( i in 5:1){
ROCplot <- roc(catergory, results[[3]][,BooteJTKsamples[i]])
if(i == 5){
plot.roc(ROCplot, legacy.axes=T, col = lineColors[i], asp = 1, lwd = 5,type = "l", pch = 16, cex = 1, xlab = "FPR", ylab = "TPR")
}
else{
lines.roc(ROCplot,col = lineColors[i], lwd = 5,type = "l", pch = 16, cex = 1)
}
}
par(mar=c(4, 4, 2, 2)+.1)
box(lwd=4)
legend(x = "bottomright",legend = x*100,fill = lineColors, inset = c(.1,.1), box.lwd = 0, title = "Noise Level \n (% Amplitude)")
BooteJTKsamples <- paste0("BooteJTK_Concat_2_24_",x,"_2")
for(i in 5:1){
ROCplot <- roc(catergory, results[[4]][,BooteJTKsamples[i]])
if(i == 5){
plot.roc(ROCplot, legacy.axes=T, col = lineColors[i], asp = 1, lwd = 5,type = "l", pch = 16, cex = 1, xlab = "FPR", ylab = "TPR")
}
else{
lines.roc(ROCplot,col = lineColors[i], lwd = 5,type = "l", pch = 16, cex = 1)
}
}
box(lwd=4)
legend(x = "bottomright",legend = x*100,fill = lineColors, text.font = 2, inset = c(.1,.1), box.lwd = 0, title = "Noise Level \n (% Amplitude)")
# waveFormCols <- c("#e41a1c","#377eb8","#4daf4a","#984ea3", "#ff7f00","#ffff33","#a65628","#cccccc", "#969696", "#636363", "#252525")
cycling <- c(rep("Cycling",7000), rep("Non-Cycling",4000))
waveFormCols <- c("#377eb8","#cccccc")
waveFormCols <- c("#FF9900",alpha("#cccccc",0.5))
dataNameSchemeA <- "BooteJTK_Avg_2_48_0_1"
data_A <- results[[3]] # corresponds to BooteJTK_Avg Data
#create Dataframe for plotting
wave <- gsub(pattern = "_.*",replacement = "",rownames(data_A))
data_A <- data.frame(-log(as.numeric(data_A[,dataNameSchemeA])),wave,cycling)
colnames(data_A) <- c('pval',"wave","cycling")
data_A$cycling  <- with(data_A, reorder(cycling, 11000:1))
ggplot(data_A, aes(x = pval,fill = cycling, color = cycling)) +
geom_histogram(boundary = 0, binwidth = 1,position = "identity") +
theme(legend.position = "bottom",
text = element_text(size = 16, face = "bold"),
panel.background=element_blank(),
panel.grid.major=element_line("black"),
plot.background=element_blank(),
panel.border = element_rect(colour = "black", fill=NA, size=3)) +
#ggtitle(paste0("Scheme A: ", dataNameSchemeA)) +
labs(x="-log(pVal)", y = "Count") +
scale_fill_manual('',values = waveFormCols)+
scale_color_manual('',values = c("black","black")) +
coord_cartesian(xlim =c(0, 50), ylim = c(0,3600))
dataNameSchemeB <- "BooteJTK_Concat_2_24_0_2"
data_B <- results[[4]] # corresponds to BooteJTK_Avg Data
#create Dataframe for plotting
wave <- gsub(pattern = "_.*",replacement = "",rownames(data_B))
data_B <- data.frame(-log(as.numeric(data_B[,dataNameSchemeB])),wave,cycling)
colnames(data_B) <- c('pval',"wave", "cycling")
data_B$cycling  <- with(data_B, reorder(cycling, 11000:1))
ggplot(data_B, aes(x = pval,fill = cycling, color = cycling)) +
geom_histogram(boundary = 0, binwidth = 1, position="identity") +
theme(legend.position = "bottom",
text = element_text(size = 16, face = "bold"),
panel.background=element_blank(),
panel.grid.major=element_line("black"),
plot.background=element_blank(),
panel.border = element_rect(colour = "black", fill=NA, size=3)) +
#ggtitle(paste0("Scheme B: ", dataNameSchemeB)) +
scale_fill_manual('',values = waveFormCols)+
scale_color_manual('',values = c("black","black")) +
labs(x="-log(pVal)", y = "Count")  +
coord_cartesian(xlim =c(0, 50), ylim = c(0,1900))
source('~/Desktop/TimeTrial/Scripts/Paper_Figures/Plot2AB.R', echo=TRUE)
